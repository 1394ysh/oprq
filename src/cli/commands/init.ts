import fs from "fs/promises";
import path from "path";
import chalk from "chalk";
import ora from "ora";
import inquirer from "inquirer";
import type { ReactQueryVersion } from "../prompts/selectReactQueryVersion.js";
import { selectReactQueryVersion } from "../prompts/selectReactQueryVersion.js";

interface InitOptions {
  output?: string;
  force?: boolean;
}

interface ProjectConfig {
  outputPath: string;
  reactQueryVersion: ReactQueryVersion;
}

const CONFIG_FILE_NAME = "orq.config.json";

/**
 * Initialize project
 * - Create config file
 * - Create utility files (StringReplacer, httpClient, etc.)
 */
export async function runInit(options: InitOptions): Promise<void> {
  console.log(chalk.bold("\n========================================"));
  console.log(chalk.bold("  orq - Initialize"));
  console.log(chalk.bold("========================================\n"));

  // Step 1: Set output path
  const { outputPath } = await inquirer.prompt([
    {
      type: "input",
      name: "outputPath",
      message: "API output path:",
      default: options.output || "./src/api",
    },
  ]);

  // Step 2: Select React Query version
  const reactQueryConfig = await selectReactQueryVersion();

  const config: ProjectConfig = {
    outputPath: path.resolve(process.cwd(), outputPath),
    reactQueryVersion: reactQueryConfig.version,
  };

  // Step 3: Save config file
  const configPath = path.join(process.cwd(), CONFIG_FILE_NAME);
  const configExists = await fileExists(configPath);

  if (configExists && !options.force) {
    const { overwrite } = await inquirer.prompt([
      {
        type: "confirm",
        name: "overwrite",
        message: `${CONFIG_FILE_NAME} already exists. Overwrite?`,
        default: false,
      },
    ]);
    if (!overwrite) {
      console.log(chalk.yellow("\nInitialization cancelled."));
      return;
    }
  }

  const spinner = ora("Creating configuration...").start();

  try {
    // Create config file (with all config keys)
    await fs.writeFile(
      configPath,
      JSON.stringify(
        {
          $schema: "https://unpkg.com/openapi-rq/schema.json",
          outputPath: outputPath,
          reactQueryVersion: reactQueryConfig.version,
          httpClient: "axios",
          typescript: true,
          specs: {
            PETSTORE: {
              url: "https://petstore3.swagger.io/api/v3/openapi.json",
              description: "Swagger Petstore API (example - can be removed)"
            }
          },
          generate: {
            queryHook: true,
            mutationHook: true,
            suspenseHook: false,
            infiniteQueryHook: false
          }
        },
        null,
        2
      )
    );
    spinner.succeed("Configuration file created");

    // Step 4: Create utility files
    spinner.start("Creating utility files...");
    await createUtilityFiles(outputPath);
    spinner.succeed("Utility files created");

    console.log(chalk.green("\nâœ“ Initialization complete!\n"));
    console.log(chalk.gray("Created files:"));
    console.log(chalk.gray(`  - ${CONFIG_FILE_NAME}`));
    console.log(chalk.gray(`  - ${outputPath}/__orq__/StringReplacer.ts`));
    console.log(chalk.gray(`  - ${outputPath}/__orq__/httpClient.ts`));
    console.log(chalk.gray(`  - ${outputPath}/__orq__/index.ts`));
    console.log("");
    console.log(chalk.yellow("ðŸ“¦ Don't forget to install peer dependencies:"));
    const queryPackage = reactQueryConfig.version === "v3" ? "react-query" : "@tanstack/react-query";
    console.log(chalk.white(`   npm install axios ${queryPackage}`));
    console.log("");
    console.log(
      chalk.cyan("Run 'orq generate' to generate API files.")
    );
    console.log("");
  } catch (error) {
    spinner.fail("Initialization failed");
    throw error;
  }
}

/**
 * Create utility files
 */
async function createUtilityFiles(outputPath: string): Promise<void> {
  const utilsDir = path.join(process.cwd(), outputPath, "__orq__");

  // Create directory
  await fs.mkdir(utilsDir, { recursive: true });

  // StringReplacer.ts
  const stringReplacerContent = `/**
 * Utility for replacing {param} placeholders in URL paths with actual values
 * Generated by orq
 */
export class StringReplacer {
  private template: string;

  constructor(template: string) {
    this.template = template;
  }

  /**
   * Replace {key} placeholders in template with values from params object
   * @param params - Key-value object for replacement
   * @returns Replaced string
   */
  replaceText(params: Record<string, string | number | undefined>): string {
    return this.template.replace(/\\{(\\w+)\\}/g, (match, key) => {
      const value = params[key];
      if (value === undefined || value === null) {
        console.warn(\`StringReplacer: Missing value for placeholder "\${key}"\`);
        return match;
      }
      return String(value);
    });
  }

  /**
   * Get original template
   */
  getTemplate(): string {
    return this.template;
  }

  /**
   * Extract placeholder keys from template
   */
  getPlaceholderKeys(): string[] {
    const matches = this.template.match(/\\{(\\w+)\\}/g);
    if (!matches) return [];
    return matches.map((m) => m.slice(1, -1));
  }
}

export default StringReplacer;
`;

  // httpClient.ts
  const httpClientContent = `/**
 * HTTP Client Bootstrap (axios only)
 * Generated by orq
 *
 * @example
 * // Set up once at app bootstrap
 * import axios from "axios";
 * import { setHttpClient } from "@/api/__orq__/httpClient";
 *
 * const instance = axios.create({ baseURL: "/api" });
 * setHttpClient(instance);
 */
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Axios config type excluding params and data (managed by generated code).
 * Use this to inject custom headers, responseType, onUploadProgress, etc.
 *
 * @example
 * // File upload with progress
 * uploadFile({
 *   body: formData,
 *   config: {
 *     headers: { 'Content-Type': 'multipart/form-data' },
 *     onUploadProgress: (e) => console.log(e.loaded / e.total)
 *   }
 * });
 *
 * // File download as blob
 * downloadFile({
 *   pathParams: { fileId },
 *   config: { responseType: 'blob' }
 * });
 */
export type RequestConfig = Omit<AxiosRequestConfig, 'params' | 'data'>;

let httpClient: AxiosInstance | null = null;

export function setHttpClient(client: AxiosInstance): void {
  httpClient = client;
}

export function getHttpClient(): AxiosInstance {
  if (!httpClient) {
    throw new Error(
      "HTTP client not initialized. Call setHttpClient(axiosInstance) in your app bootstrap."
    );
  }
  return httpClient;
}

/**
 * Helper to extract data from axios response
 */
export async function unwrap<T>(promise: Promise<AxiosResponse<T>>): Promise<T> {
  const response = await promise;
  return response.data;
}
`;

  // index.ts
  const indexContent = `/**
 * API Utilities
 * Generated by orq
 */
export { StringReplacer } from "./StringReplacer";
export { setHttpClient, getHttpClient, unwrap, type RequestConfig } from "./httpClient";
`;

  await fs.writeFile(path.join(utilsDir, "StringReplacer.ts"), stringReplacerContent);
  await fs.writeFile(path.join(utilsDir, "httpClient.ts"), httpClientContent);
  await fs.writeFile(path.join(utilsDir, "index.ts"), indexContent);
}

/**
 * Check if file exists
 */
async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Load config file
 */
export async function loadConfig(): Promise<ProjectConfig | null> {
  const configPath = path.join(process.cwd(), CONFIG_FILE_NAME);

  try {
    const content = await fs.readFile(configPath, "utf-8");
    return JSON.parse(content);
  } catch {
    return null;
  }
}
