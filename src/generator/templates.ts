import fs from "fs/promises";
import path from "path";
import { ensureDirectory } from "../utils/files.js";

const OPRQ_FOLDER = "__oprq__";

/**
 * StringReplacer.ts 템플릿 (접두사 유지)
 */
export function getStringReplacerTemplateWithPrefix(): string {
  return `/**
 * URL 경로 파라미터 치환 유틸리티
 * Generated by oprq
 */
export class StringReplacer {
  private template: string;

  constructor(template: string) {
    this.template = template;
  }

  /**
   * 경로 파라미터 치환 (스펙 접두사 유지)
   * @example "PETSTORE:/pet/{petId}" + { petId: 1 } => "PETSTORE:/pet/1"
   */
  replaceText(params: Record<string, string | number | undefined>): string {
    return this.template.replace(/\\{(\\w+)\\}/g, (match, key) => {
      const value = params[key];
      if (value === undefined || value === null) {
        console.warn(\`StringReplacer: Missing value for placeholder "\${key}"\`);
        return match;
      }
      return String(value);
    });
  }

  /**
   * Get original template
   */
  getTemplate(): string {
    return this.template;
  }

  /**
   * URL에서 경로 파라미터 목록 추출
   */
  getPlaceholders(): string[] {
    const matches = this.template.match(/\\{(\\w+)\\}/g);
    return matches ? matches.map((m) => m.slice(1, -1)) : [];
  }
}
`;
}

/**
 * StringReplacer.ts 템플릿 (접두사 제거)
 */
export function getStringReplacerTemplateWithoutPrefix(): string {
  return `/**
 * URL 경로 파라미터 치환 유틸리티
 * Generated by oprq
 */
export class StringReplacer {
  private template: string;

  constructor(template: string) {
    this.template = template;
  }

  /**
   * 스펙 접두사 제거 및 경로 파라미터 치환
   * @example "PETSTORE:/pet/{petId}" + { petId: 1 } => "/pet/1"
   */
  replaceText(params: Record<string, string | number | undefined>): string {
    // 스펙 이름 접두사 제거 (예: "PETSTORE:/pet/{petId}" => "/pet/{petId}")
    let result = this.template.replace(/^[A-Z][A-Z0-9_]*:/, "");

    // 경로 파라미터 치환
    result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {
      const value = params[key];
      if (value === undefined || value === null) {
        console.warn(\`StringReplacer: Missing value for placeholder "\${key}"\`);
        return match;
      }
      return String(value);
    });

    return result;
  }

  /**
   * Get original template
   */
  getTemplate(): string {
    return this.template;
  }

  /**
   * URL에서 경로 파라미터 목록 추출
   */
  getPlaceholders(): string[] {
    const matches = this.template.match(/\\{(\\w+)\\}/g);
    return matches ? matches.map((m) => m.slice(1, -1)) : [];
  }
}
`;
}

/**
 * StringReplacer.ts 템플릿 (옵션에 따라 선택)
 */
export function getStringReplacerTemplate(keepSpecPrefix: boolean = true): string {
  return keepSpecPrefix
    ? getStringReplacerTemplateWithPrefix()
    : getStringReplacerTemplateWithoutPrefix();
}

/**
 * httpClient.ts 템플릿
 */
export function getHttpClientTemplate(): string {
  return `/**
 * HTTP Client Bootstrap (axios only)
 * Generated by oprq
 *
 * @example
 * // Basic setup
 * import axios from "axios";
 * import { setHttpClient } from "@/api/__oprq__/httpClient";
 *
 * const instance = axios.create({ baseURL: "/api" });
 * setHttpClient(instance);
 *
 * @example
 * // With response/error handlers (for custom http wrappers)
 * setHttpClient(customHttp.axiosInstance, {
 *   onResponse: (result) => {
 *     // Transform response or handle errors that come as resolved values
 *     if (result instanceof Error) throw result;
 *     return result;
 *   },
 *   onError: (error) => {
 *     // Transform error before rejecting
 *     throw { code: error.response?.status, message: error.message };
 *   },
 * });
 */
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Axios config type excluding params and data (managed by generated code).
 * Use this to inject custom headers, responseType, onUploadProgress, etc.
 *
 * @example
 * // File upload with progress
 * uploadFile({
 *   body: formData,
 *   config: {
 *     headers: { 'Content-Type': 'multipart/form-data' },
 *     onUploadProgress: (e) => console.log(e.loaded / e.total)
 *   }
 * });
 *
 * // File download as blob
 * downloadFile({
 *   pathParams: { fileId },
 *   config: { responseType: 'blob' }
 * });
 */
export type RequestConfig = Omit<AxiosRequestConfig, 'params' | 'data'>;

/**
 * Options for customizing HTTP client behavior
 */
export interface HttpClientOptions {
  /**
   * Transform successful response before returning.
   * Also useful when your interceptor returns errors as resolved values.
   * @example (response) => response.data
   * @example (result) => result instanceof Error ? Promise.reject(result) : result
   */
  onResponse?: (response: any) => any;

  /**
   * Transform error before rejecting.
   * @example (error) => { throw { code: error.response?.status, message: error.message } }
   */
  onError?: (error: any) => any;
}

let httpClient: AxiosInstance | null = null;
let responseHandler: ((response: any) => any) | null = null;
let errorHandler: ((error: any) => any) | null = null;

export function setHttpClient(
  client: AxiosInstance,
  options?: HttpClientOptions
): void {
  httpClient = client;  // 원본 그대로 저장 (싱글톤 유지)
  responseHandler = options?.onResponse ?? null;
  errorHandler = options?.onError ?? null;
}

export function getHttpClient(): AxiosInstance {
  if (!httpClient) {
    throw new Error(
      "HTTP client not initialized. Call setHttpClient(axiosInstance) in your app bootstrap."
    );
  }
  return httpClient;
}

/**
 * Apply response/error handlers to a request promise.
 * Used internally by generated API code.
 */
export async function request<T>(promise: Promise<T>): Promise<T> {
  try {
    const result = await promise;
    return responseHandler ? await responseHandler(result) : result;
  } catch (error) {
    if (errorHandler) return await errorHandler(error);
    throw error;
  }
}

/**
 * Helper to extract data from axios response
 */
export async function unwrap<T>(promise: Promise<AxiosResponse<T>>): Promise<T> {
  const response = await promise;
  return response.data;
}
`;
}

/**
 * queryKey.ts 템플릿
 */
export function getQueryKeyTemplate(): string {
  return `/**
 * React Query Key 생성 유틸리티
 * Generated by oprq
 *
 * URL 패턴에서 타입 안전한 Query Key 배열을 생성합니다.
 */

/**
 * HTTP Method 타입
 */
export type HttpMethod = "GET" | "POST" | "PUT" | "PATCH" | "DELETE";

/**
 * URL 패턴에서 {param} 형식의 파라미터 키를 추출하는 Template Literal Type
 *
 * @example
 * type Params = ExtractUrlParams<'/api/{userId}/posts/{postId}'>;
 * // => 'userId' | 'postId'
 */
export type ExtractUrlParams<T extends string> =
  T extends \`\${string}{\${infer Param}}\${infer Rest}\`
    ? Param | ExtractUrlParams<Rest>
    : never;

/**
 * URL 패턴에서 파라미터 키를 추출하여 Record 타입 생성
 *
 * @example
 * type PathVariable = UrlParamsToRecord<'/api/{userId}/posts/{postId}'>;
 * // => { userId: string | number; postId: string | number }
 */
export type UrlParamsToRecord<T extends string> = {
  [K in ExtractUrlParams<T>]: string | number;
};

/**
 * URL 패턴에서 파라미터가 없는 경우를 처리하기 위한 조건부 타입
 */
type HasUrlParams<T extends string> = ExtractUrlParams<T> extends never
  ? false
  : true;

/**
 * Query Key 생성을 위한 요청 타입 (path 타입 자동 추론용)
 *
 * @example
 * // URL에 path variable이 있는 경우
 * type Req1 = TypedQueryKeyRequest<'/api/{userId}', { userId: number }, { status: string }, { name: string }>;
 *
 * // URL에 path variable이 없는 경우
 * type Req2 = TypedQueryKeyRequest<'/api/users/list', Record<string, never>, { page: number }, undefined>;
 */
export type TypedQueryKeyRequest<
  TUrl extends string,
  TPath extends Record<string, unknown> | undefined = Record<string, unknown> | undefined,
  TParam extends Record<string, unknown> | undefined = Record<string, unknown> | undefined,
  TBody extends Record<string, unknown> | undefined = Record<string, unknown> | undefined
> = {
  /** HTTP Method (예: 'GET', 'POST') */
  method?: HttpMethod;
  /** Path 파라미터 (예: { userId: 123 }) */
  path?: TPath;
  /** Query string 파라미터 (예: { name: 'hi', page: 1 }) */
  param?: TParam;
  /** Request body */
  body?: TBody;
};

/**
 * 타입 안전한 URL 파라미터 치환
 * URL 상수를 제네릭으로 전달하면 필요한 파라미터를 자동 추론
 *
 * @param urlPattern - URL 패턴 문자열 (as const 필수)
 * @param params - 치환할 파라미터 객체 (타입 자동 추론)
 * @returns 치환된 URL 문자열
 *
 * @example
 * const URL = '/api/{userId}/posts/{postId}' as const;
 *
 * // ✅ OK
 * replaceUrlParams(URL, { userId: '123', postId: '456' });
 * // => '/api/123/posts/456'
 *
 * // ❌ TypeScript 에러: Property 'postId' is missing
 * replaceUrlParams(URL, { userId: '123' });
 *
 * // ❌ TypeScript 에러: 'wrongKey' does not exist
 * replaceUrlParams(URL, { userId: '123', postId: '456', wrongKey: 'x' });
 */
export const replaceUrlParams = <T extends string>(
  urlPattern: T,
  ...args: HasUrlParams<T> extends true ? [params: UrlParamsToRecord<T>] : []
): string => {
  const params = args[0] as Record<string, string | number> | undefined;

  if (!urlPattern) return "";
  if (!params) return urlPattern;

  return urlPattern.replace(/\\{([^}]+)\\}/g, (_, key) => {
    const value = params[key];
    return value !== undefined ? String(value) : "";
  });
};

/**
 * URL 패턴을 파싱하여 React Query Key 배열 생성 (타입 안전)
 *
 * @param urlPattern - URL 패턴 문자열 (as const 필수)
 * @param request - { method, path, param, body } 형식의 요청 객체
 * @returns Query Key 배열
 *
 * @example
 * // 생성된 코드에서 사용 (제네릭 명시)
 * generateQueryKey<typeof API_URL, PathParams, QueryParams, Body>(API_URL, {
 *   method: "GET",
 *   path: req.pathParams,
 *   param: req.queryParams,
 *   body: req.body,
 * });
 * // => ["GET", "SPEC", "path", 123, { query }, { body }]
 */
export const generateQueryKey = <
  TUrl extends string,
  TPath extends Record<string, unknown> | undefined = Record<string, unknown> | undefined,
  TParam extends Record<string, unknown> | undefined = Record<string, unknown> | undefined,
  TBody extends Record<string, unknown> | undefined = Record<string, unknown> | undefined
>(
  urlPattern: TUrl,
  request?: TypedQueryKeyRequest<TUrl, TPath, TParam, TBody>
): unknown[] => {
  const { method, path, param, body } =
    request ?? ({} as TypedQueryKeyRequest<TUrl, TPath, TParam, TBody>);

  // URL 패턴을 세그먼트로 분리
  const segments = urlPattern
    .split(/[:/]/)
    .filter(Boolean)
    .map((segment) => {
      // {variable} 패턴 치환
      const match = segment.match(/^\\{(.+)\\}$/);

      if (match && path) {
        return (path as Record<string, unknown>)[match[1]];
      }
      return segment;
    });

  const result: unknown[] = [];

  // method가 있으면 맨 앞에 추가
  if (method) {
    result.push(method);
  }

  result.push(...segments);

  // param이 있으면 추가
  if (param && Object.keys(param).length > 0) {
    result.push(param);
  }

  // body가 있으면 마지막에 추가
  if (body && Object.keys(body).length > 0) {
    result.push(body);
  }

  return result;
};
`;
}

/**
 * index.ts 템플릿
 */
export function getIndexTemplate(): string {
  return `/**
 * API Utilities
 * Generated by oprq
 */
export { StringReplacer } from "./StringReplacer";
export {
  setHttpClient,
  getHttpClient,
  request,
  unwrap,
  type RequestConfig,
  type HttpClientOptions,
} from "./httpClient";
export {
  generateQueryKey,
  replaceUrlParams,
  type HttpMethod,
  type ExtractUrlParams,
  type UrlParamsToRecord,
  type TypedQueryKeyRequest,
} from "./queryKey";
`;
}

/**
 * __oprq__ 폴더 및 유틸리티 파일 생성
 */
export async function ensureOprqFolder(outputPath: string): Promise<string> {
  const oprqPath = path.join(outputPath, OPRQ_FOLDER);
  await ensureDirectory(oprqPath);
  return oprqPath;
}

/**
 * 모든 유틸리티 파일 생성
 * @param outputPath 출력 경로
 * @param keepSpecPrefix 스펙 접두사 유지 여부 (기본값: true)
 */
export async function generateUtilityFiles(outputPath: string, keepSpecPrefix: boolean = true): Promise<void> {
  const oprqPath = await ensureOprqFolder(outputPath);

  await Promise.all([
    fs.writeFile(path.join(oprqPath, "StringReplacer.ts"), getStringReplacerTemplate(keepSpecPrefix)),
    fs.writeFile(path.join(oprqPath, "httpClient.ts"), getHttpClientTemplate()),
    fs.writeFile(path.join(oprqPath, "queryKey.ts"), getQueryKeyTemplate()),
    fs.writeFile(path.join(oprqPath, "index.ts"), getIndexTemplate()),
  ]);
}

/**
 * 유틸리티 파일 존재 여부 확인
 */
export async function oprqFolderExists(outputPath: string): Promise<boolean> {
  const oprqPath = path.join(outputPath, OPRQ_FOLDER);
  try {
    await fs.access(oprqPath);
    return true;
  } catch {
    return false;
  }
}
