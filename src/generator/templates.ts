import fs from "fs/promises";
import path from "path";
import { ensureDirectory } from "../utils/files.js";

const OPRQ_FOLDER = "__oprq__";

/**
 * StringReplacer.ts 템플릿 (접두사 유지)
 */
export function getStringReplacerTemplateWithPrefix(): string {
  return `/**
 * URL 경로 파라미터 치환 유틸리티
 * Generated by oprq
 */
export class StringReplacer {
  private template: string;

  constructor(template: string) {
    this.template = template;
  }

  /**
   * 경로 파라미터 치환 (스펙 접두사 유지)
   * @example "PETSTORE:/pet/{petId}" + { petId: 1 } => "PETSTORE:/pet/1"
   */
  replaceText(params: Record<string, string | number | undefined>): string {
    return this.template.replace(/\\{(\\w+)\\}/g, (match, key) => {
      const value = params[key];
      if (value === undefined || value === null) {
        console.warn(\`StringReplacer: Missing value for placeholder "\${key}"\`);
        return match;
      }
      return String(value);
    });
  }

  /**
   * Get original template
   */
  getTemplate(): string {
    return this.template;
  }

  /**
   * URL에서 경로 파라미터 목록 추출
   */
  getPlaceholders(): string[] {
    const matches = this.template.match(/\\{(\\w+)\\}/g);
    return matches ? matches.map((m) => m.slice(1, -1)) : [];
  }
}
`;
}

/**
 * StringReplacer.ts 템플릿 (접두사 제거)
 */
export function getStringReplacerTemplateWithoutPrefix(): string {
  return `/**
 * URL 경로 파라미터 치환 유틸리티
 * Generated by oprq
 */
export class StringReplacer {
  private template: string;

  constructor(template: string) {
    this.template = template;
  }

  /**
   * 스펙 접두사 제거 및 경로 파라미터 치환
   * @example "PETSTORE:/pet/{petId}" + { petId: 1 } => "/pet/1"
   */
  replaceText(params: Record<string, string | number | undefined>): string {
    // 스펙 이름 접두사 제거 (예: "PETSTORE:/pet/{petId}" => "/pet/{petId}")
    let result = this.template.replace(/^[A-Z][A-Z0-9_]*:/, "");

    // 경로 파라미터 치환
    result = result.replace(/\\{(\\w+)\\}/g, (match, key) => {
      const value = params[key];
      if (value === undefined || value === null) {
        console.warn(\`StringReplacer: Missing value for placeholder "\${key}"\`);
        return match;
      }
      return String(value);
    });

    return result;
  }

  /**
   * Get original template
   */
  getTemplate(): string {
    return this.template;
  }

  /**
   * URL에서 경로 파라미터 목록 추출
   */
  getPlaceholders(): string[] {
    const matches = this.template.match(/\\{(\\w+)\\}/g);
    return matches ? matches.map((m) => m.slice(1, -1)) : [];
  }
}
`;
}

/**
 * StringReplacer.ts 템플릿 (옵션에 따라 선택)
 */
export function getStringReplacerTemplate(keepSpecPrefix: boolean = true): string {
  return keepSpecPrefix
    ? getStringReplacerTemplateWithPrefix()
    : getStringReplacerTemplateWithoutPrefix();
}

/**
 * httpClient.ts 템플릿
 */
export function getHttpClientTemplate(): string {
  return `/**
 * HTTP Client Bootstrap (axios only)
 * Generated by oprq
 *
 * @example
 * // Basic setup
 * import axios from "axios";
 * import { setHttpClient } from "@/api/__oprq__/httpClient";
 *
 * const instance = axios.create({ baseURL: "/api" });
 * setHttpClient(instance);
 *
 * @example
 * // With response/error handlers (for custom http wrappers)
 * setHttpClient(customHttp.axiosInstance, {
 *   onResponse: (result) => {
 *     // Transform response or handle errors that come as resolved values
 *     if (result instanceof Error) throw result;
 *     return result;
 *   },
 *   onError: (error) => {
 *     // Transform error before rejecting
 *     throw { code: error.response?.status, message: error.message };
 *   },
 * });
 */
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * Axios config type excluding params and data (managed by generated code).
 * Use this to inject custom headers, responseType, onUploadProgress, etc.
 *
 * @example
 * // File upload with progress
 * uploadFile({
 *   body: formData,
 *   config: {
 *     headers: { 'Content-Type': 'multipart/form-data' },
 *     onUploadProgress: (e) => console.log(e.loaded / e.total)
 *   }
 * });
 *
 * // File download as blob
 * downloadFile({
 *   pathParams: { fileId },
 *   config: { responseType: 'blob' }
 * });
 */
export type RequestConfig = Omit<AxiosRequestConfig, 'params' | 'data'>;

/**
 * Options for customizing HTTP client behavior
 */
export interface HttpClientOptions {
  /**
   * Transform successful response before returning.
   * Also useful when your interceptor returns errors as resolved values.
   * @example (response) => response.data
   * @example (result) => result instanceof Error ? Promise.reject(result) : result
   */
  onResponse?: (response: any) => any;

  /**
   * Transform error before rejecting.
   * @example (error) => { throw { code: error.response?.status, message: error.message } }
   */
  onError?: (error: any) => any;
}

let httpClient: AxiosInstance | null = null;
let responseHandler: ((response: any) => any) | null = null;
let errorHandler: ((error: any) => any) | null = null;

export function setHttpClient(
  client: AxiosInstance,
  options?: HttpClientOptions
): void {
  httpClient = client;  // 원본 그대로 저장 (싱글톤 유지)
  responseHandler = options?.onResponse ?? null;
  errorHandler = options?.onError ?? null;
}

export function getHttpClient(): AxiosInstance {
  if (!httpClient) {
    throw new Error(
      "HTTP client not initialized. Call setHttpClient(axiosInstance) in your app bootstrap."
    );
  }
  return httpClient;
}

/**
 * Apply response/error handlers to a request promise.
 * Used internally by generated API code.
 */
export async function request<T>(promise: Promise<T>): Promise<T> {
  try {
    const result = await promise;
    return responseHandler ? await responseHandler(result) : result;
  } catch (error) {
    if (errorHandler) return await errorHandler(error);
    throw error;
  }
}

/**
 * Helper to extract data from axios response
 */
export async function unwrap<T>(promise: Promise<AxiosResponse<T>>): Promise<T> {
  const response = await promise;
  return response.data;
}
`;
}

/**
 * index.ts 템플릿
 */
export function getIndexTemplate(): string {
  return `/**
 * API Utilities
 * Generated by oprq
 */
export { StringReplacer } from "./StringReplacer";
export {
  setHttpClient,
  getHttpClient,
  request,
  unwrap,
  type RequestConfig,
  type HttpClientOptions,
} from "./httpClient";
`;
}

/**
 * __oprq__ 폴더 및 유틸리티 파일 생성
 */
export async function ensureOprqFolder(outputPath: string): Promise<string> {
  const oprqPath = path.join(outputPath, OPRQ_FOLDER);
  await ensureDirectory(oprqPath);
  return oprqPath;
}

/**
 * 모든 유틸리티 파일 생성
 * @param outputPath 출력 경로
 * @param keepSpecPrefix 스펙 접두사 유지 여부 (기본값: true)
 */
export async function generateUtilityFiles(outputPath: string, keepSpecPrefix: boolean = true): Promise<void> {
  const oprqPath = await ensureOprqFolder(outputPath);

  await Promise.all([
    fs.writeFile(path.join(oprqPath, "StringReplacer.ts"), getStringReplacerTemplate(keepSpecPrefix)),
    fs.writeFile(path.join(oprqPath, "httpClient.ts"), getHttpClientTemplate()),
    fs.writeFile(path.join(oprqPath, "index.ts"), getIndexTemplate()),
  ]);
}

/**
 * 유틸리티 파일 존재 여부 확인
 */
export async function oprqFolderExists(outputPath: string): Promise<boolean> {
  const oprqPath = path.join(outputPath, OPRQ_FOLDER);
  try {
    await fs.access(oprqPath);
    return true;
  } catch {
    return false;
  }
}
